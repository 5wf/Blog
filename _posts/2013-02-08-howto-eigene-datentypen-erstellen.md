---
layout: post
title: "Howto: Eigene Datentypen erstellen"
date: 2013-02-08 07:00
author: oliver.guhr
comments: true
categories: [Allgemein, HowTo]
tags: []
---
{% include JB/setup %}
<p>Ich möchte an dieser Stelle noch einen zweiten Artikel zu diesem eigentlich recht unscheinbaren Thema nachreichen (<a href="http://code-inside.de/blog/2012/10/24/einheiten-und-schnittstellen/">hier ist der erste Artikel</a>). Es geht dabei darum, wie man Einheiten in seinem Code abbildet, die nicht im Framework vorhanden sind, wie Datengrößen(MB, GB), Längeneinheiten oder Temperaturen. Nach dem ich den ersten Artikel zum dem Thema veröffentlicht hatte, gab es Einiges an Feedback unter andrem von <a href="https://twitter.com/norberteder">Norbert</a> und vor allem von meinem Kollegen <a href="http://www.erik-baum.de" >Erik Baum</a>, der sich mit dem Thema noch mal etwas ausführlicher beschäftigt hat. Erik hat den Datentyp um einige coole Features erweitert die ich hier mal kurz beschreiben will:</p> <p>&nbsp;</p> <h3>struct vs. class</h3> <p><a href="{{BASE_PATH}}/assets/wp-images/image1755.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb909.png" width="554" height="58"></a></p> <p>Die erste Frage die mir gestellt wurde war: Warum hast du für deinen Datentypen kein struct verwendet? Structs kannte ich noch aus C und für mich waren sie so was wie der Vorläufer der Klassen. Das es stucts auch in C# gibr wusste ich, aber nicht warum/wann man sie benutzen sollte.<br>Hier die kuze Antwort: <br>Structs benutzt man um Typen zu erstellen die sich wie ein integrierter Datentypen verhalten, z.B. wie DateTime. Und genau das wollten wir ja. Der Vorteil ist der geringer Overhead und damit Speicherverbrauch. Structs können dafür aber nicht alles was Klassen können. Eine Liste dazu findet man in der <a href="http://msdn.microsoft.com/de-de/library/saxz13w4(v=vs.110).aspx">MSDN</a>. Etwas ausführlicher wird das ganze <a href="http://openbook.galileocomputing.de/csharp/kap09.htm">hier beschrieben</a>.</p> <p>&nbsp;</p> <h3>Überladene Operatoren</h3> <p><a href="{{BASE_PATH}}/assets/wp-images/image1756.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb910.png" width="552" height="208"></a></p> <p>Wenn wir schon einen Datentypen bauen, dann wäre es doch schön wenn er genauso einfach wie die Datetime und co. zu benutzen ist. Um die Operatoren + – / == und co zu verwenden müssen diese überladen werden. Das geht eigentlich ganz einfach und bringt eine menge Komfort beim benutzen.&nbsp; </p> <p>&nbsp;</p> <h3>Der implicit Operator</h3>      <p><a href="{{BASE_PATH}}/assets/wp-images/image1757.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb911.png" width="556" height="210"></a></p> <p>Der implicit Operator ermöglicht das Konvertieren von Datentypen ohne das man es extra angeben müsste. Mit Hilfe dieses Operators wird folgende Anweisung möglich:</p> <p><a href="{{BASE_PATH}}/assets/wp-images/image1758.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb912.png" width="559" height="58"></a></p> <h3>IComparable und IEquatable</h3> <p><a href="{{BASE_PATH}}/assets/wp-images/image1759.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb913.png" width="559" height="53"></a></p> <p>Wir lassen unser struct noch von diesen 2 Interfaces erben. Wenn man diese implementiert hat man die Möglichkeit, viele coole Framework Features einfach zu nutzen. Die Sort Funktion für Arrays und Lists nutzt z.B. das IComparable Interface, deshalb können wir Listen dann einfach so sortieren:</p> <p><a href="{{BASE_PATH}}/assets/wp-images/image1760.png"><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb914.png" width="564" height="48"></a></p> <p>&nbsp;</p> <p>Den kompletten Code für die DataSize struct gibt es <a href="https://github.com/Code-Inside/Samples/tree/master/2013/DataTypes">hier zum Download.</a></p>
