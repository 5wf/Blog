---
layout: post
title: "Ist eine 3 Schichten Architektur mit eigener DAL immer empfehlenswert?"
date: 2010-08-03 23:06
author: robert.muehsig
comments: true
categories: [HowToCode]
tags: []
---
{% include JB/setup %}
<p><a href="{{BASE_PATH}}/assets/wp-images/image1018.png"><img style="border-right-width: 0px; margin: 0px 10px 0px 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" align="left" src="{{BASE_PATH}}/assets/wp-images/image_thumb202.png" width="189" height="174" /></a> </p>  <p>Wenn es darum geht eine "normale” Webapplikation zu bauen, dann kommt man meist auf eine 3 Schichten Architektur heraus. Der <a href="{{BASE_PATH}}/2008/07/09/howto-3-tier-3-schichten-architektur/">meistgelesenste Blogeintrag dreht sich um diese Architektur</a>, allerdings kommen bei mir immer mal wieder Zweifel auf, ob man nicht zuviel Aufwand in der DAL betreibt - immerhin gibt es tolle OR Mapper. Doch auch damit bin ich bereits auf die Nase gefallen und hab mich von dem Gebrauch dieser <a href="{{BASE_PATH}}/2009/03/13/howtocode-macht-ein-eigenes-model-ohne-linq2sqladonet-ef-magic/">Linq2Sql oder Entity Framework generierten Model-Klassen distanziert</a>. <a href="http://ayende.com/Blog/archive/2010/07/30/the-false-myth-of-encapsulating-data-access-in-the-dal.aspx">Ayende Rahien</a> hat aber mal wieder meine Zweifel geweckt...</p> <!--more-->  <p><strong>3-Schichten Architektur</strong></p>  <p>Ayende selbst ist bekennender Fan von NHibernate (immerhin hat er es mitentwickelt) und mag auch das Repository Pattern wohl auch nicht mehr so.</p>  <p>Allerdings sind die Grundgedanken vollkommen nachvollziehbar. Die Grafiken stammen aus einem von Ayendes Posts. Der normale Aufbau wäre bei einer 3-Schichten Architektur so:</p>  <p><a href="{{BASE_PATH}}/assets/wp-images/image1019.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb203.png" width="496" height="214" /></a> </p>  <p>Der Ablauf sobald ein User z.B. auf einen bestimmten Eintrag auf einer Website klickt wäre so:</p>  <p><a href="{{BASE_PATH}}/assets/wp-images/image1020.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images/image_thumb204.png" width="557" height="193" /></a> </p>  <p>Ihn stört es, dass man durch Repositories noch eine weitere Abstraktionsebene aufbaut. In den meisten meiner Projekte hatten wir es auch so umgesetzt und in dem "Data&quot; Layer noch einen ORM, wie z.B. Linq2Sql oder das Entity Framework benutzt.</p>  <p><strong>Zu viel Abstraktion? </strong></p>  <p>Die Frage die ich mir stelle: Lohnt sich der Aufwand (und <a href="http://ayende.com/Blog/archive/2008/11/21/stealing-from-your-client.aspx">die Kosten für den Kunden</a>) den Data-Layer zu kapseln, wenn man ohnehin ein OR Mapper benutzt? </p>  <p>Kann man denn realistisch und mit vertretbaren Aufwänden überhaupt eine gescheites IUserRepository bauen? <a href="http://ayende.com/Blog/archive/2010/07/30/the-false-myth-of-encapsulating-data-access-in-the-dal.aspx">Ayende hat ein paar Punkte aufgezählt</a>, warum die Kapselung eines Data Access Layers unnötig auch nicht wirklich umsetzbar ist. <a href="http://ayende.com/Blog/archive/2010/08/02/abstracting-the-persistence-medium-isnrsquot-going-to-let-you-switch.aspx">In einem weiteren Post</a> geht er genau ein und zeigt anhand des Membership Providers (den ich persönlich für grausam erachte), dass es vergebene Mühe ist.</p>  <p><strong>Durch die Kapselung wird es leichter mit Unit-Tests die Businesslogik zu testen!</strong></p>  <p>Durch ein Projekt wo wir in der Businesslogik direkt Linq2Sql und das Entity Framework eingesetzt haben, war es äußerst mühsam bis unmöglich Unit-Tests zu schreiben. Daher war es für die Testbarkeit der Businessschicht enorm wichtig, dass man die DAL auch mocken kann. Allerdings sind die beiden OR/M ja nicht die einzigen .NET OR/M...</p>  <p><strong>NHibernate</strong></p>  <p>Ayende ging auch in einem Post auf das <a href="http://ayende.com/Blog/archive/2009/04/18/mocking-nhibernate.aspx">Mocking von NHibernate</a> ein und wie man auch <a href="http://ayende.com/Blog/archive/2009/04/28/nhibernate-unit-testing.aspx">Unit-Tests</a> abbilden kann. </p>  <p><strong>Die große Frage (und warum ich diesen Post schreibe)</strong></p>  <p>Mach ich mir das Leben selber kompliziert indem ich versuche die DAL zu kapseln? Nehm ich vielleicht einfach nur die falschen OR/Mapper? Ist NHibernate so toll und kann mir jemand ein tolles Beispielprojekt samt Unit-Tests zeigen? :)</p>  <p>Ist eine 3-Schichten Architektur am Ende immer erstrebenswert? <em>(Achtung: Ich geh hier von einem 0815 Webprojekt aus und zählen den OR/Mapper nicht als direkte Schicht, sondern ich würde direkt in der Business-Schicht NHibernate arbeiten. Dass es im Embedded Bereich andere Spielregel gibt ist mir klar ;) )</em></p>
