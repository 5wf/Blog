---
layout: post
title: "Keep it simple! YAGNI!"
date: 2011-11-04 21:54
author: robert.muehsig
comments: true
categories: [Allgemein]
tags: [CQRS, KISS]
language: de
---
{% include JB/setup %}
<p>Dauerbrenner auf dem Blog ist der Artikel <a href="{{BASE_PATH}}/2008/07/09/howto-3-tier-3-schichten-architektur/">HowTo: 3-Tier / 3-Schichten Architektur</a>. Allerdings hatte ich schon einige Zeit Zweifel (<a href="{{BASE_PATH}}/2010/08/03/ist-eine-3-schichten-architektur-mit-eigner-dal-immer-empfehlenswert/">Ist eine 3 Schichten Architektur mit eigener DAL immer empfehlenswert?</a>)daran, dass dieses Standardvorgehen immer der richtige Weg ist. Vor ein paar Tagen hatte ich dann einen interessanten Blogpost gelesen, welcher in die gleiche Richtung geht: <strong><a href="http://daniellang.net/keep-your-code-simple/">Keep your code simple!</a></strong></p> <p><strong>Von Spaghetti-Code zum Lasagne-Code</strong></p> <p>Jeder Entwickler hat verstanden, dass es nicht gesund ist 1000 Zeilen Code zu produzieren, welche nur für eine Funktion gut sind. Die Trennung in Schichten kann allerdings auch in das andere Extrem schlagen: <a href="http://c2.com/cgi/wiki?LasagnaCode">Lasagne Code</a>. Dutzende Schichten Code, ohne das sie wirklich was machen. Einfach nur, damit die Objekte von Schicht zu Schicht wandern. </p> <p><strong>KISS &amp; YAGNI</strong></p> <p>Bevor man grundlos eine 3-Schichten Architektur wählt, sollte man sich die Frage stellen: <u>Wozu brauch ich dies eigentlich? <br></u>Wozu Repository-, Business und Presentation-Layer? Wenn man wirklich zwei Frontends (WebApp und Fat-Client), dann mag das clever sein – aber meisten braucht man es nicht (<strong>YAGNI</strong>). Je mehr Schichten, desto langsamer wird die Entwicklung. Da eine Schnittstelle definieren und dort noch ein Property hinzufügen und dieses dann implementieren und das nur, weil man plötzlich auf der Website ein Feld mehr anzeigen will. </p> <p><strong>Mh… und wie könnte eine Lösung aussehen?</strong></p> <p>Ich bin mittlerweile recht pragmatisch geworden und hab auch keine so große Schmerzen mehr die Datenabfrage direkt im Controller (im ASP.NET MVC Sinne) zu machen. <br>Erst wenn ich die Abfrage doch noch woanders brauche, mach ich mir intensivere Gedanken ob man dies nicht in eine Art “Query”-Klasse auslagern kann. </p> <p>Schreibende Vorgänge würde ich anfangs ebenso behandeln – erst wenn man es an mehreren Stellen braucht, würde ich dies in “Command”-Klassen auslagern. </p> <p>Ziel davon: Copy/Paste sollte natürlich nach wie vor vermieden werden – die Businesslogik doppelt zu halten ist der falsche Weg.</p> <p><strong>Und wie steht es mit Unit-Tests?</strong></p> <p>Der einzige Knackpunkt an der Sache ist, dass man ohne Interfaces etc. natürlich schlechter mocken kann. Allerdings bin ich mir mittlerweile auch unsicher, welchen Wert diese Unit-Tests haben. Dutzende Tests, welche gegen Mocks gehen und 5 Zeilen Code testen. </p> <p>Integrationstests, welche die gesamte Applikation testen, sind am Ende “aussagekräftiger” – dies kann z.B. über eine SQLLiteDb erfolgen oder man geht gegen die richtige (aber langsame Datenbank) etc. Bei einem kleinen Projekt, welches keine großen Abhängigkeiten hat, sollte dies im Bereich des machbaren liegen. Je größer die Backendsysteme, desto eher muss man sich einen Kopf darum machen, wie man das am Ende testen möchte.</p> <p><strong>“Poor-Mans CQRS”</strong></p> <p><a href="http://www.cqrsinfo.com/">CQRS</a> ist ein nettes Konzept, welches die Trennung von Queries (Abfragen) und Commands (Schreibende Aktionen) vorsieht (und noch weit mehr).&nbsp; </p> <p>Daniel Lang (Autor vom Blogpost “<a href="http://daniellang.net/keep-your-code-simple/">Keep your code simple!</a>”) hatte für seinen Ansatz den Begriff “Poor-Mans CQRS” gewählt – gefällt mir :)</p> <p><strong>Was am Ende zählt…</strong></p> <p>Am Ende des Tages muss immer eine funktionstüchtige Software rauskommen. Die Software sollte ihren Zweck erfüllen und es nützt nichts wenn man immer “streng nach Vorschrift” entwickelt – “es kommt halt drauf an…”.</p> <p><strong>TL;DR</strong></p> <p>Bevor man anfängt sich dutzende Schichten zurecht zu bauen, um auch alles mit Mocks und Unit-Tests ausstatten zu können sollte man sich die Frage stellen: Brauch ich das überhaupt? Was ist das Ziel? Vermeidet trotzdem Copy/Paste und lagert Sachen nach dem Prinzip “CQRS” aus – Queries für lesende Sachen und Commands für Aktionen. </p>
