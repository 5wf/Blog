---
layout: post
title: "Gegen die Mega-.sln – NuGet Packages vs. Projekt Referenzen"
date: 2013-06-21 00:09
author: robert.muehsig
comments: true
categories: [HowToCode]
tags: [NuGet]
language: de
---
{% include JB/setup %}
<p>Je länger man an einem Anwendung arbeitet desto eher steigt auch die Projektanzahl in der Solution an – Solutions mit 80 Projekten sind keine Seltenheit. Allerdings merkt man das selbst Visual Studio zum Teil damit kämpft und die Performance nicht ideal ist. </p> <h3>Was macht man mit den ganzen Projekten?</h3> <p>Man erstellt natürlich nicht sinnlos irgendwelche Projekte, sondern der Kerngedanke ist das man bestimmte Komponten einfach kapseln und wiederverwenden kann. Der Grundgedanke ist daher nicht verkehrt.</p> <p><strong>Aber man arbeitet selten an allen Komponenten gleichzeitig, oder?</strong></p> <p>Hier kommt der Punkt der mich am meisten stört: Natürlich arbeitet man meist nicht an allen Komponenten/Projekten gleichzeitig – zum Teil können Projekte nur Schnittstellendefinitionen enthalten, welche in der Regel nicht ständig verändert werden. </p> <p><strong>Und trotzdem sind sie die ganze Zeit in der Solution drin…</strong></p> <p>Da man die einzelnen Komponenten einfach in der Solution untereinander referenziert werden oftmals völlig unnötige Build-Schritte gemacht. </p> <p>Was könnte man dagegen machen?</p> <h3>Idee: NuGet – Packages als Ersatz für Projekt Referenzen</h3> <p>NuGet gibt es schon eine ganze Weile – allerdings nutzt man es zumeist nur für 3rd Party Libraries (jedenfalls geht es mir so) . Aber natürlich könnte man NuGet – Packages auch für die eigenen Komponenten nehmen. Schauen wir uns das Konzept mal in einer Demo-Anwendung an:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1851.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; margin: 0px 10px 0px 0px; border-left: 0px; display: inline" border="0" alt="image" align="left" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb999.png" width="231" height="204"></a> </p> <p>Wir haben eine “Haupt-Anwendung” und eine Assembly die irgendwelche Business-Logik enthält. Nun möchten wir hier aber nicht direkt das “Business”-Projekt referenzieren. </p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p>&nbsp;</p> <p><strong>Wie erzeugt man ein NuGet Package?</strong></p> <p>Ich selber habe auch noch nicht selbst viele NuGet Packages erstellt – meist habe ich es einfach nur als normaler Anwender genutzt, daher ist dies als “prototypische Implementierung” zu verstehen ;) Erster Einstiegspunkt wäre die <a href="http://docs.nuget.org/docs/creating-packages/creating-and-publishing-a-package">NuGet Doku</a>. </p> <p>Wichtigstes Tool ist NuGet.exe (die aktuelle Version ist in der Doku verlinkt). Über das Tool kann man NuGet Packages erstellen, updaten und eine ganze Liste weitere Dinge machen:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1852.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1000.png" width="559" height="417"></a> </p> <p>Die NuGet.exe kann man auch nach belieben kopieren und ausführen wo man möchte. </p> <p><u>Ein Package erzeugen geht über den Aufruf “pack” mit der Angabe der Projektdatei (csproj):</u></p> <p><em>NuGet.exe pack Business\Business.csproj -build -Outputdirectory ..\NugetShare\ –Version 1.2.3.4</em></p> <p>Kurze Erläuterung:</p> <p>Wir geben hier den Pfad zur csproj Datei an und über –build wird das Projekt nochmal explizit gebaut. Danach folgt der Ausgabeort des NuGet Packages und am Ende ein Versionsnummer, welche für NuGet wichtig ist.</p> <p>Als Ergebnis bekommen wir dies in der Kommandozeile zu sehen:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1853.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1001.png" width="576" height="154"></a> </p> <p>Da wir als Basis eine Projektdatei und kein <a href="http://nuget.codeplex.com/wikipage?title=File%20Element%20Specification">NuGet Spec File</a> nutzen fehlen ein paar Meta-Daten – daher auch die Warnungen. Über das Spec File könnte man wesentlich interessantere Szenarien abdecken – hier ging es aber erst einmal nur um das referienzieren von einer Assembly.</p> <p><strong>Der NuGet.exe Output</strong></p> <p>Das Tool erzeugt am Ende ein .nupkg, welche alles enthält:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1854.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1002.png" width="520" height="158"></a> </p> <p>Wer genauer in ein .nupkg reinschauen will benötigt den <a href="http://docs.nuget.org/docs/creating-packages/using-a-gui-to-build-packages">NuGet Package Explorer</a>:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1855.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1003.png" width="480" height="420"></a> </p> <p><strong>Eigenen NuGet Feed in Visual Studio einbinden</strong></p> <p>Damit Visual Studio unsere NuGet Packages auch kennt muss dieser in den Optionen hinterlegt werden:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1856.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1004.png" width="500" height="305"></a> </p> <p><strong>Das NuGet Package nutzen</strong></p> <p>Ähnlich wie ich auch von NuGet.org die Packages lade, kann ich jetzt einfach von dem Verzeichnis aus die Komponente in das Haupt-Projekt importieren (und damit referenzieren).</p> <p>In diesem Fall wird mir ein Update angeboten, da ich bereits eine ältes Package installiert habe.</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1857.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1005.png" width="514" height="354"></a> </p> <p><strong>Kann man das Package debuggen?</strong></p> <p>In meinem Demo konnte der Debugger die Assembly, welche aus dem NuGet Package kam zu dem entsprechenden Projekt zuordnen:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1858.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1006.png" width="240" height="87"></a> </p> <p>Ob dies in jedem Fall geht muss man allerdings überprüfen. Bislang sieht es aber recht vielversprechend aus.</p> <h3><strong>Was haben wir jetzt als Ergebnis?</strong></h3> <p>Wir haben eine Haupt-Anwendung und eine Komponente, welche nur durch das NuGet Package miteinander verbunden sind. Natürlich ist die Assembly (von dem NuGet Package) in den Referenzen drin, aber es gibt keine direkte Build-Dependency:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1859.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb1007.png" width="496" height="327"></a></p> <p>Bei einem “Rebuild” der MainApp wird auch nur das Projekt gebaut – hier vermeidet man das man die Business-Schicht immer mit baut.</p> <p><strong>Welche Nachteile ergeben sich?</strong></p> <p>Die Denkweise von “Referenzen” zu “Packages” ist eine Umstellung und es lohnt sich vermutlich erst wirklich bei großen Solutions. Wenn man ohnehin wirklich ständig an allen Assemblies Veränderungen durchführt ist das natürlich ungünstig. </p> <p>Auch muss man sich ein Konzept für die NuGet Version überlegen. <a href="http://semver.org/">SemVer.org</a> ist hier ein gutes Stichwort.</p> <p>Man benötigt im Team irgendwo ein Share auf dem das gesamte Team zugreifen kann und dieser Share sollte auch stabil zur Verfügung stehen. Es gibt noch andere Wege einen NuGet Feed zu hosten – aber ein File-Share ist die einfache Möglichkeit. Wer einen direkten Dienst benutzen möchte (also ein privates NuGet.org) der auch ein Blick auf <a href="http://www.myget.org/">MyGet.org</a> werfen (NuGet as a Service).</p> <p>Damit das ganze Spass macht, sollte man vermutlich auch ein Build-System haben und sich ein vollständigen Workflow überlegen. Hier ein paar Fragen die mir spontan einfallen:<br>- Wann baut man die Komponente mit welcher Version? <br>- Wer startet diesen Prozess?<br>- Wie sieht das Testing aus? Gibt es hier eine Art Freigabe-Prozess?<br>- Version der Assembly = NuGet Package Version?<br>- Assemblies signieren – geht danach das Debugging noch?</p> <p>NuGet einzuführen bringt Komplexität mit sich – aber ein +100 Projekte umfassende Solution ist auch nicht gerade wartbar ;)</p> <h3><strong>Gute Idee? Schlechte Idee?</strong></h3> <p>Vermutlich haben schon einige ein ähnliches System auf Basis von NuGet im Einsatz. Falls jemand aus der Community Erfahrungen mit “Inhouse-NuGet-Packages” hat, kann er dies gern über einen Kommentar weitergeben.</p>
