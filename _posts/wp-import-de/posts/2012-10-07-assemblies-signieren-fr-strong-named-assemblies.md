---
layout: post
title: "Assemblies signieren für Strong Named Assemblies"
date: 2012-10-07 14:22
author: Robert Muehsig
comments: true
categories: [HowTo]
tags: [Assembly, HowTo, Signing]
language: de
---
{% include JB/setup %}

<h2>Updated on 2016-07-19: Don't do it... it's not helpful and a waste of time.</h2>
<p>
<b>Huge warning!</b> There might be very very few reasons for Strong Naming, but I can't name you a single one. Try to avoid it at all time. Please read <a href="http://strongnamingconsideredharmful.com/">Strong Naming Considered Harmful</a>.
</p>

<p>Assemblies zu signieren ist relativ einfach – solange man entsprechend valide Zertifikate für Code Signierung hat. Sobald Assemblies signiert sind haben sie einen “starken Namen” bzw. sind “Strong Named” – diese Begrifflichkeiten liesst man immer wieder. </p> <p>Am Anfang möchten ich aber mal auf die Frage eingehen: </p> <p><strong>Warum sollte man Assemblies signieren?</strong></p> <p>Wer als Web-Entwickler unterwegs ist und auch nur Server-Software schreibt die in einem “kontrolliertem” (d.h. vom Entwickler selbst) Umfeld läuft braucht diesen Prozess eigentlich nicht machen. Auch in vielen Kundenprojekten war dies nie Anforderung und auch nicht wirklich wichtig. </p> <p>Kniffliger wird es bei Client-Software oder Software, welche auf vielen Kundensystem installiert wird.</p> <p><strong>Was sind die Vorteile?</strong></p> <p>Die Assembly hat einen eindeutigen Namen, sodass es auch zu keiner Verwechslung mit anderen Assmblies kommen kann. <em>Wobei ich hier dazu sagen muss: Ich hatte noch nie “versehentlich” eine falsche Assembly geladen.</em></p> <p>Wichtigster Punkt: Im Grunde wird sichergestellt, dass die Anwendung keine “verfälschten” oder manipulierten Assemblies lädt. Niemand kann eine Fälschung der System.dll erzeugen und Schad-Code hinzufügen – dies könnte nur der Herausgeber selbst machen. Insbesondere bei Client-Software ist der Punkt des Vertrauens wichtig. Ein böses Szenario könnte sein, dass man eine sehr verbreitete Software angreift indem man Programm dlls austauscht – ohne starken Namen würde das Programm die manipulierten Assemblies laden. </p> <p>Weitere Punkte sind z.B. <a href="http://stackoverflow.com/questions/2354129/why-use-strong-named-assemblies">hier</a> zu finden.</p> <p><strong>Was sind die Nachteile?</strong></p> <p>Es macht initial (etwas) Arbeit die Assemblies zu signieren und das in ein Build-System zu integrieren. Zudem benötigt man ein Zertifikat, welches für Code Signierung gemacht wurde. Ein SLL Zertifikat geht in diesem Fall nicht (für Demo Zwecke kann aber das Visual Studio solch ein Zertifikat generieren.)</p> <p><u>Ein wesentlich größerer Nachteil ist allerdings</u>, dass eine Assembly nur signiert werden kann wenn alle anderen benötigten Assemblies auch mit starken Namen ausgestattet sind. <u>Sobald eine Komponente von einem dritt Anbieter nicht mit starkem Namen ausgeliefert wird funktioniert es <strong>nicht</strong>.</u></p> <p>Es gibt einige NuGet Packages, welche Assemblies mit starken Namen ausliefern, allerdings ist das vermutlich nur ein Bruchteil. Wer seine Assemblies also signieren möchte, sollte schauen ob alle Bibliotheken auch von den Herausgebern signiert sind. </p> <p><strong>Ok… wie funktioniert nun die Signierung über Visual Studio?</strong></p> <p>In Visual Studio gibt es über die Projekteigenschaften die Einstellung “Signing” – dort kann man ein bestehendes Key File auswählen oder ein neues Test-Zertifikat auswählen.</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1602.png"><img title="image" style="border-top: 0px; border-right: 0px; border-bottom: 0px; border-left: 0px; display: inline" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb763.png" width="579" height="332"></a></p> <p>Bei jedem Build wird nun die Assembly signiert.</p> <p>Negativ bei dieser Variante: Es wird bei jedem Build die Signierung gemacht und jeder Entwickler bräuchte das Key File – was allerdings irgendwie auch nicht gerade Zielführend ist.</p> <p><strong>Bessere Variante: Über ein Build Server bzw. MSBuild zum Signieren</strong></p> <p>Über MSBuild kann man auch sehr einfach die Signierung anstoßen:</p> <p><em><code>msbuild myapp.sln /p:SignAssembly=true /p:AssemblyOriginatorKeyFile=mykey.snk</code></em></p> <p>Anstatt dem .snk File kann man auch ein PFX File nehmen – aber Achtung: <strong>Ein SSL Zertifikat geht </strong><a href="http://stackoverflow.com/questions/5444077/is-it-possible-to-sign-my-assembly-with-an-ssl-certificate"><strong>für die Code Signierung nicht</strong></a>! Ansonsten wird beim PFX File allerdings am Anfang noch folgende Fehlermeldung kommen:</p> <p><em>Cannot import the following key file: Foobar.pfx. The key file may be password protected. To correct this, try to import the certificate again or manually install the certificate to the Strong Name CSP with the following key container name: VS_KEY_AE50D88C1F0F7433&nbsp;&nbsp;&nbsp; StrongNameBlogpost</em>  <p>Über diesen Befehl kann man die PFX importieren: </p> <p><strong><code>sn -i companyname.pfx VS_KEY_CONTAINER</code></strong>&nbsp; </p> <p>Achtung: Wer ein SSL Zertifkat nimmt bekommt hier keinen Fehler – beim Bauen wird allerdings weiterhin der “Cannot import…” Fehler angezeigt.</p> <p>Der MSBuild Befehl kann in die meisten Build Systeme einfach aufgerufen werden. </p><p><strong>Update: Falls der MSBuild Aufruf mit dem .pfx trotz sn -i ... nicht funktioniert:</strong></p><p>Ich hatte das Problem, dass MSBuild auch nach einem erfolgreichen sn -i Aufruf das .pfx nicht kennen wollte. Ein Workaround ist in diesem Fall den KeyContainerName (VS_KEY_CONTAINER...) direkt anzugeben:</p><p><code>msbuild myapp.sln /p:SignAssembly=true /p:AssemblyKeyContainerName="VS_KEY_..."</code></p><p><strong>Wie finde ich heraus ob eine Assembly signiert ist?</strong></p> <p><strong><code>sn -vf myassembly.dll/exe</code></strong>&nbsp; </p> <p>Als Ergebnis sollte dann: “Assembly ‘…’ is valid”</p> <p><strong>Wie bekomme ich den Public Key Token heraus?</strong></p> <p>Auch hier ist der einfachste Weg über das sn Tool:</p> <p><code>sn –Tp myassembly.dd/exe</code></p> <p>Achtung: Groß- und Kleinschreibung spielt eine Rolle.</p> <p>Ergebnis sollte sowas sein:</p> <p><a href="{{BASE_PATH}}/assets/wp-images-de/image1601.png"><img title="image" style="border-left-width: 0px; border-right-width: 0px; border-bottom-width: 0px; display: inline; border-top-width: 0px" border="0" alt="image" src="{{BASE_PATH}}/assets/wp-images-de/image_thumb762.png" width="536" height="136"></a> </p> <p><strong>Ich find das sn.exe Tool nicht!</strong></p> <p>Am Besten die Visual Studio 2010 Command Prompt Starten – ansonsten versteckt es sich hier:</p> <p><code>C:\Program Files (x86)\Microsoft SDKs\Windows\v7.0A\bin\sn.exe</code></p> <p>bzw. unter Windows 7:</p> <p><code>C:\Program Files (x86)\Microsoft SDKs\Windows\v6.0A\bin\sn.exe</code></p>
