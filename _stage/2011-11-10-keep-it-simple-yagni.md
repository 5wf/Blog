---
layout: post
title: "Keep it simple! YAGNI!"
date: 2011-11-10 20:24
author: antje.kilian
comments: true
categories: [Uncategorized]
tags: []
language: en
---
{% include JB/setup %}
<p>Evergreen on this blog is the Howto: <a href="http://code-inside.de/blog-in/2010/10/23/howto-3-tier-3-layer-architecture/">3-Tier / 3-Layers architecture</a>. But in fact I had some doubts if this usual practice is the best way. Is a three layer architecture with an own DAL always recommendable?</p> <p>A few days ago I’ve read an interesting blog post which goes the same direction: <a href="http://daniellang.net/keep-your-code-simple/">Keep your code simple!</a></p> <p><strong></strong></p> <p><strong>From Spaghetti-Code to Lasagne-Code</strong></p> <p>Every developer knows that it’s not necessary to produce a code with 100000 lines for only one function. But it’s possible to reach another extreme: a <a href="http://c2.com/cgi/wiki?LasagnaCode">Lasagne Code</a>. You have Countless layers of code only to make the object move from one layer to the next.</p> <p><strong></strong></p> <p><strong>KISS &amp; YAGNI</strong></p> <p><strong></strong></p> <p>Before you create an 3-layer architecture without any reason you should ask you one question: Why do I need this?</p> <p>Why Repository-, Business and Presentation-Layer? Of course it makes sense if you have two Frontends (WebApp and Fat-Client) – but you don’t need it most of the time (<strong>YAGNI</strong>). The more layers the slower the development process runs. Define another surface here and add a new property there and implement it and only because you want one more field to be shown on the website.</p> <p><strong>Mh… so how to solve this problem? </strong></p> <p><strong></strong></p> <p>I’m pragmatic now and I feel no pain to make the data retrieval directly on the controller (in the sense of ASP.NET MVC). Not until I need the retrieval somewhere else I start thinking about creating a several “Query” class.</p> <p>I recommend you to do the same with writing processes – do not create a “Command” class before you really need to.</p> <p>Intent of this: Copy/Paste should be avoided anyway – double the business logic is the wrong way.</p> <p><strong>And what’s about Unit-Tests?</strong></p> <p><strong></strong></p> <p>That’s the point. Without an interface and all this stuff it’s hard to mock. But at least I’m not sure about the real value of Unit-Tests. Countless tests going against Mocks to test at least 5 lines of code.</p> <p>Integrationtests testing the whole application are at least more significant. These are possible with a SQLLiteDb or you use the usual (but slow) file base and so on.</p> <p>This should be practicable in a little project without many addictions. How bigger the Backendsystems you need to think about how to test it at the end.</p> <p><strong>“Poor-Man’s CQRS”</strong></p> <p><a href="http://www.cqrsinfo.com/">CQRS</a> is a nice concept to divide Queries and Commands (and a lot more).</p> <p>Daniel Lang (author of the Blogpost <a href="http://daniellang.net/keep-your-code-simple/">“Keep your code simple!”)</a> choose the phrase “Poor-Man’s CQRS” - I like it <img style="border-bottom-style: none; border-right-style: none; border-top-style: none; border-left-style: none" class="wlEmoticon wlEmoticon-openmouthedsmile" alt="Smiley mit ge&ouml;ffnetem Mund" src="http://code-inside.de/blog-in/wp-content/uploads/wlEmoticon-openmouthedsmile1.png"></p> <p><strong>What counts in the end…</strong></p> <p>At the end of the day the software should work. It should attain his goal and it’s not useful to work “by the book” – it depends…</p> <p><strong></strong></p> <p><strong>TL;DR</strong></p> <p>Before you start building numerous layers and put many Mocks and Unit-Tests in it you should ask yourself: Is this really necessary? What’s the aim? But remember to avoid Copy/Paste and age things after the “CQRS” Principe – Queries for reading things and Commands for actions.</p>
